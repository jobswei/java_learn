#### 静态方法
无需实例化就可以调用的方法是静态方法(static),想在静态方法中调用非静态方法，需要先将非静态方法所在的类实例化

#### 局部变量
* 声明在方法中，方法执行完就被销毁 
* 不能被访问修饰符修饰 
* 没有默认值 
#### 实例变量
* 声明在类中，方法外  
* 类被实例化后，实例变量就跟着确定
* 可以被访问修饰符修饰 public, private,,  
* 在对象创建的时候创建，在对象被销毁的时候销毁
#### 类变量（静态变量）
* 以static 关键字声明
* 所有实例化对象的类变量都是同一个值  
* 第一次被访问时创建，在程序结束时销毁
* 类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母

#### 访问修饰符 
* private：只有本类可见
* protected：同一包的所有类可见，不同包的子类可以访问从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。
* default：同一包内可见
* 所有包可见

#### 非访问修饰符
|---|---|
static|静态方法不能使用类的非静态变量
final|修饰的类不能被继承，修饰的方法不能被重写，修饰的变量不可更改
abstract|修饰抽象类和抽象方法。含有抽象方法的类必须定义为抽象类
synchronized&volatile|用于线程的编程

#### character类
在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。  
在某些情况下，Java编译器会自动创建一个Character对象。例如，将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。  
Character类含有很多方法，如: isDigit(),isWhitespace(),isLowerCase(),toLowerCase(),toString()...  

#### String类
可以直接等于，也可以等于new String(".."), 还可以将char[]塞进括号里。

#### 方法重载
一个类的两个方法拥可以有相同的名字，但是要有不同的参数列表。重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。  

#### 命令行
从命令行的输入被储存在args数组中  
```java
public class CommandLine {
   public static void main(String[] args){ 
      for(int i=0; i<args.length; i++){
         System.out.println("args[" + i + "]: " + args[i]);
      }
   }
}
/*
$ javac CommandLine.java 
$ java CommandLine this is a command line 200 -100
args[0]: this
args[1]: is
args[2]: a
args[3]: command
args[4]: line
args[5]: 200
args[6]: -100
*/
```

#### 抽象类和抽象方法
* 抽象类不能被实例化，只能通过被继承发挥作用
* 抽象方法直接加分号，不包含方法体  
* 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。  

#### 接口
* 接口无法被实例化，但是可以被实现。 
* 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法  

#### 重写与重载
重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！  
重载(overloading)： 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。  最常用的地方就是构造器的重载。